% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_trend_surface.R
\name{fit_trend_surface}
\alias{fit_trend_surface}
\title{Fit a trend surface to sky digital numbers}
\usage{
fit_trend_surface(sky_points, r, np = 6, col_id = "dn")
}
\arguments{
\item{sky_points}{An object of class \emph{data.frame}. The data.frame returned by
\code{\link[=extract_rel_radiance]{extract_rel_radiance()}} or \code{\link[=extract_dn]{extract_dn()}}, or a
\emph{data.frame} with same basic structure and names.}

\item{r}{\linkS4class{SpatRaster}. The image from which the argument \code{sky_points}
was obtained.}

\item{np}{
degree of polynomial surface
}

\item{col_id}{Numeric or character vector of length one. The number or name
of the colum with the values to interpolate.}
}
\value{
A list with an object of class \linkS4class{SpatRaster} and of class \code{trls}
(see \code{\link[spatial:surf.ls]{spatial::surf.ls()}}).
}
\description{
Fit a trend surface using \code{\link[spatial:surf.ls]{spatial::surf.ls()}} as workhorse function.
}
\details{
This function is meant to be used after \code{\link[=fit_coneshaped_model]{fit_coneshaped_model()}}.

The first application of trend surface fitting to modelling sky digital
numbers was presented in \insertCite{Diaz2018;textual}{rcaiman}, under the
heading \emph{Estimation of the sky DN as a previous step for our method}. The
example shows a pipeline that resemble the one presented in that paper. The
original idea was developed after the programming of \code{\link[=extract_sky_points]{extract_sky_points()}}.
}
\note{
If an incomplete above-canopy image is available as filling source,
non-sky pixels should be turned \code{NA} or they will be erroneously considered
as sky pixels.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
bin <- regional_thresholding(r, rings_segmentation(z, 30),
                             method = "thr_isodata")
mx <- optim_max(caim, bin)
caim <- normalize_minmax(caim, 0, mx, TRUE)

sky_blue <- polarLAB(50, 17, 293)
ecaim <- enhance_caim(caim, m, sky_blue = sky_blue)
bin <- apply_thr(ecaim, thr_isodata(ecaim[m]))

g <- sky_grid_segmentation(z, a, 10, first_ring_different = TRUE)
sky_points <- extract_sky_points(r, bin, g, dist_to_black = 3)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
rr <- extract_rel_radiance(r, z, a, sky_points)

sky_s <- fit_trend_surface(rr$sky_points, r, col_id = "dn")
plot(sky_s$raster)
plot(r/sky_s$raster)
apply_thr(r/sky_s$raster, 0.5) \%>\% plot()

model <- fit_coneshaped_model(rr$sky_points)
summary(model$model)
sky_cs <- model$fun(z, a) * rr$zenith_dn
plot(sky_cs)

.r <- r
.r[!bin] <- sky_cs
plot(.r)
sky_points <- extract_sky_points(.r, m, g, dist_to_black = 3)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
rr <- extract_rel_radiance(.r, z, a, sky_points)

sky_s <- fit_trend_surface(rr$sky_points, .r, col_id = "dn")
plot(sky_s$raster)
plot(r/sky_s$raster)
apply_thr(r/sky_s$raster, 0.5) \%>\% plot()
}
}
\references{
\insertAllCited{}
}
\seealso{
\code{\link[=thr_mblt]{thr_mblt()}}
}
