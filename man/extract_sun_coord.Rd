% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_sun_coord.R
\name{extract_sun_coord}
\alias{extract_sun_coord}
\title{Extract sun coordinates}
\usage{
extract_sun_coord(r, z, a, bin, g, max_angular_dist = 30)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically,
the blue channel extracted from an hemispherical photograph. Please see
\code{\link{read_caim}} and \code{\link{normalize}}.}

\item{z}{\linkS4class{SpatRaster} built with
\code{\link{zenith_image}}.}

\item{a}{\code{\linkS4class{SpatRaster}} built with
\code{\link{azimuth_image}}.}

\item{bin}{\linkS4class{SpatRaster}. This should be a preliminary
binarization of \code{r} useful for masking pixels that are very likely
pure sky pixels.}

\item{g}{\linkS4class{SpatRaster}. The result of a call to
\code{\link{sky_grid_segmentation}} taking into account the camera, lens,
and pre-processing involved in obtaining the \code{r} argument.}

\item{max_angular_dist}{Numeric vector of length one. Angle in degree to
establish the maximum size of the sun corona, see details.}
}
\value{
Object of class list with two elements names \emph{row_col} and
  \emph{zenith_azimuth}, both are numeric vectors of length two. The former is
  raster coordinates of the solar disk (row and column), and the other is
  angular coordinates (zenith and azimuth angles in degrees).
}
\description{
Extract the sun coordinates for CIE sky model fitting.
}
\details{
This function uses an object-based image analyze theoretical framework. The
segmentation are given by \code{g} and \code{bin}. For every cell of
\code{g}, the maximum is calculated from the pixel values on \code{r} that
have a value equal to one on \code{bin}. Then, the quantile 0.95 is computed
from these maximum values and it is used to filter out cells below that
threshold; i.e, only the ones with at least one extremely bright sky pixel is
keep.

Selected cells are grouped into segments based on adjacency. The degree of
membership to the class \emph{Sun} is calculated for every segment by using
linear membership functions for the features brightness --digital number from
\code{r}-- and size -- number of cells that constitute the segment. In other
words, the brighteners and lagers segments are the ones that score higher.
The one with the highest score is selected as the \emph{sun seed}.

The angular distance from the sun seed to every other segments are computed,
and only the segments not farther than \code{max_angular_dist} are classified
as part of the sun corona. A multi-part segment is created by merging the
sun-corona segments and, finally, the center of its bounding box is
considered as the sun location.

The \code{bin} argument should be the same than for
\code{\link{extract_sky_points}}.
}
\examples{
\dontrun{
caim <- read_caim() \%>\% normalize()
z <- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a <- azimuth_image(z)
sky_blue_sample <- crop(caim, ext(610,643,760,806))
sky_blue <- apply(sky_blue_sample[], 2, median) \%>\%
  as.numeric() \%>\%
  matrix(., ncol = 3) \%>\%
  sRGB()
ecaim <- enhance_caim(caim, !is.na(z), sky_blue, gamma = 2.2)
bin <- apply_thr(ecaim, 0.75)
g <- sky_grid_segmentation(z, a, 10)
r <- gbc(caim$Blue*255)
sun_coord <- extract_sun_coord(r, z, a, bin, g, max_angular_dist = 30)
xy <- cellFromRowCol(z, sun_coord$row_col[1], sun_coord$row_col[2]) \%>\%
  xyFromCell(z, .)
plot(r)
plot(vect(xy), add = TRUE, col = 2)
}
}
\seealso{
fit_cie_sky_model
}
\concept{HSP functions}
