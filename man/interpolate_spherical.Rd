% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate_spherical.R
\name{interpolate_spherical}
\alias{interpolate_spherical}
\title{Expand sky points}
\usage{
interpolate_spherical(
  r,
  z,
  a,
  sky_points,
  filling_source,
  k,
  p,
  chi_max = 20,
  w = 1,
  size = 50,
  rule = "any",
  use_window = TRUE,
  return_raster = TRUE
)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A greyscale image.}

\item{z}{\linkS4class{SpatRaster} built with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\linkS4class{SpatRaster} built with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{sky_points}{The output of \code{\link[=extract_sky_points]{extract_sky_points()}}
or an object of the same class and structure.}

\item{filling_source}{Single-layer \linkS4class{SpatRaster} or \code{NULL}.  A source to
complement the sky pixels detected through the gaps of \code{r}. See
\code{\link[=ootb_fit_cie_sky_model]{ootb_fit_cie_sky_model()}}.}

\item{k}{Numeric vector of length one. Number of k-nearest neighbors.}

\item{p}{Numeric vector of length one. Power for inverse-distance weighting.}

\item{chi_max}{Numeric vector of length one. Maximum spherical distance (in
degrees) to search for nearest neighbors.}

\item{w}{Numeric vector of length one. Weight parameter for the sky model.}

\item{size}{Numeric vector of length one. Number of rows and colums of the
planar grid that will be the skeleton for intepolating the points.}

\item{rule}{Character vector of length one. Either \code{"any"} or \code{"all"}.}

\item{use_window}{Logical vector of length one. If \code{TRUE}, a window of \eqn{3
\times 3} pixels will be used to extract the digital number from \code{r}.}

\item{return_raster}{Logical vector of length one. If \code{TRUE} (default), then
raster will be returned. Otherwise, a \emph{data.frame} representing points
distributed in a regular grid will be returned.}
}
\value{
An object of the class \emph{data.frame}. It is the input argument
\code{sky_points} with the following additional data:
\itemize{
\item Rows resulting of interpolating the \code{sky_points} argument.
\item Columns \emph{a}, \emph{z}, \emph{dn}, and \emph{initial}.
\itemize{
\item \emph{a}, the azimuthal angle.
\item \emph{z}:, the zenithal angle.
\item \emph{dn}, the digital number.
\item \emph{initial}, if 'TRUE' the point is from the \code{sky_points} argument.
}
}
}
\description{
Expand sky points using a \emph{k} nearest neighbors approach and IDW
interpolation. Equation 6 from Lang et al. 2006
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
bin <- apply_thr(r, thr_isodata(r[]))
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)


path <- system.file("external/ootb_sky.txt", package = "rcaiman")
ootb_sky <- read_ootb_sky_model(gsub(".txt", "", path), z, a)

sky_points <- ootb_sky$sky_points

size <- 200
sky_points2 <- interpolate_spherical(r, z, a, sky_points,
                                     sky_model =  ootb_sky$sky,
                                     k = 10,
                                     p = 2,
                                     w = 1,
                                     rule = "any",
                                     chi_max = 20,
                                     size = size)
plot(sky)
}
}
