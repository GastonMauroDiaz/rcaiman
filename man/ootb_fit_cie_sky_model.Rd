% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ootb_fit_cie_sky_model.R
\name{ootb_fit_cie_sky_model}
\alias{ootb_fit_cie_sky_model}
\title{Out-of-the-box fit CIE sky model}
\usage{
ootb_fit_cie_sky_model(
  r,
  z,
  a,
  m,
  bin,
  g,
  sor_filter_cv = FALSE,
  sor_filter_dn = FALSE,
  refine_sun_coord = FALSE,
  min_spherical_dist = NULL,
  input_sky_points = NULL
)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see \code{\link[=read_caim]{read_caim()}}
and \code{\link[=normalize]{normalize()}}.}

\item{z}{\linkS4class{SpatRaster} built with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\linkS4class{SpatRaster} built with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{m}{\linkS4class{SpatRaster}. A mask, check \code{\link[=mask_hs]{mask_hs()}}.}

\item{bin}{\linkS4class{SpatRaster}. This should be a preliminary binarization of
\code{r} useful for masking pixels that are very likely pure sky pixels.}

\item{g}{\linkS4class{SpatRaster} built with \code{\link[=sky_grid_segmentation]{sky_grid_segmentation()}} or
\code{\link[=chessboard]{chessboard()}}.}

\item{sor_filter_cv}{Logical vector of length one. If \code{TRUE}, \code{\link[=sor_filter]{sor_filter()}}
will be applied internally to filter out points using local variability at
the scale of the \eqn{3 \times 3} window using for data extraction as the
criterion. Local means not farther than 30 degrees.}

\item{sor_filter_dn}{Logical vector of length one. If \code{TRUE}, \code{\link[=sor_filter]{sor_filter()}}
will be applied internally to filter out points using local darkness as the
criterion. Local means not farther than 20 degrees.}

\item{refine_sun_coord}{Logical vector of length one}

\item{min_spherical_dist}{Numeric vector of length one. This parameter
filters out points based on their proximity on a spherical surface.
Essentially, this is the spherical counterpart of the \code{min_raster_dist}
argument from \code{\link[=extract_sky_points]{extract_sky_points()}}. The distance is expressed in degrees.}

\item{input_sky_points}{An object of class \emph{data.frame} with the same
structure than the output of \code{\link[=extract_sky_points]{extract_sky_points()}}. This argument is
convinient to provide manually digitized points, see \code{\link[=fit_cie_sky_model]{fit_cie_sky_model()}}
for details.}
}
\value{
A \emph{list} with the following components:
\itemize{
\item An object of the \linkS4class{SpatRaster}) with the predicted digital
number values.
\item The output produced by \code{\link[=fit_cie_sky_model]{fit_cie_sky_model()}}.
\item The output produced by \code{\link[=validate_cie_sky_model]{validate_cie_sky_model()}}.
\item The \code{dist_to_plant} argument used in \code{\link[=fit_cie_sky_model]{fit_cie_sky_model()}}.
\item The \code{sky_points} argument used in \code{\link[=extract_rl]{extract_rl()}}.
}
}
\description{
This function is a hard-coded version of a pipeline that uses these main
functions \code{\link[=extract_sun_coord]{extract_sun_coord()}}, \code{\link[=extract_sky_points]{extract_sky_points()}}, \code{\link[=sor_filter]{sor_filter()}},
\code{\link[=extract_rl]{extract_rl()}}, \code{\link[=fit_cie_sky_model]{fit_cie_sky_model()}}, and \code{\link[=validate_cie_sky_model]{validate_cie_sky_model()}}.
}
\details{
This function is part of the efforts to automate the method proposed by
\insertCite{Lang2010;textual}{rcaiman}. A paper for thoroughly presenting and
testing this pipeline is under preparation.
}
\examples{
\dontrun{
caim <- read_caim()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

r <- caim$Blue

bin <- regional_thresholding(r, rings_segmentation(z, 30),
                             method = "thr_isodata")
g <- sky_grid_segmentation(z, a, 10)
sun_coord <- extract_sun_coord(r, z, a, bin, g)
sun_coord$zenith_azimuth

.a <- azimuth_image(z, orientation = sun_coord$zenith_azimuth[2]+90)
seg <- sectors_segmentation(.a, 180) * rings_segmentation(z, 30)
bin <- regional_thresholding(r, seg, method = "thr_isodata")

mx <- optim_normalize(caim, bin)
caim <- normalize(caim, mx = mx, force_range = TRUE)
ecaim <- enhance_caim(caim, m, polarLAB(50, 17, 293))
bin <- apply_thr(ecaim, thr_isodata(ecaim[m]))
bin <- bin & mask_hs(z, 0, 85)
plot(bin)

set.seed(7)
g <- sky_grid_segmentation(z, a, 10, first_ring_different = TRUE)
sky <- ootb_fit_cie_sky_model(r, z, a, m, bin , g,
                              sor_filter_cv = TRUE, sor_filter_dn = TRUE,
                              refine_sun_coord = TRUE,
                              min_spherical_dist = 3)

sky$sky
plot(sky$sky)
sky$model_validation$rmse
plot(r/sky$sky>1.15)
plot(sky$model_validation$predicted, sky$model_validation$observed)
abline(0,1)
error <- sky$model_validation$predicted - sky$model_validation$observed
plot(sky$sky_points$z[!sky$sky_points$outliers], error,
     xlab = "zenith angle", ylab = "relative radiance error")
abline(h = 0)

plot(bin)
points(sky$sky_points$col, nrow(caim) - sky$sky_points$row, col = 2, pch = 10)

}
}
\references{
\insertAllCited{}
}
\seealso{
Other Sky Reconstruction Functions: 
\code{\link{cie_sky_image}()},
\code{\link{fit_cie_sky_model}()},
\code{\link{fit_coneshaped_model}()},
\code{\link{fit_trend_surface}()},
\code{\link{interpolate_and_merge}()},
\code{\link{interpolate_sky_points}()}
}
\concept{Sky Reconstruction Functions}
