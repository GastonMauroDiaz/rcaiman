% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/equalarea_segmentation.R
\name{equalarea_segmentation}
\alias{equalarea_segmentation}
\title{Segment a hemisphere into equal-area cells in spherical space}
\usage{
equalarea_segmentation(z, a, n_cells)
}
\arguments{
\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} single-layer raster with zenith angle (degrees).}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} single-layer raster with azimuth angle (degrees).}

\item{n_cells}{numeric scalar. Target number of cells.}
}
\value{
Single-layer \link[terra:SpatRaster-class]{terra::SpatRaster} with integer values from 1 to \code{n_cells}.
}
\description{
Segment a hemispherical view into \code{n_cells} equal-area cells in
spherical space.
}
\details{
Segmentation begins by creating \code{n_cells} initial rings through uniform
sampling in \code{cos(z)} space. The core logic of the algorithm is grouping \code{k}
initial rings into a larger ring and then subdividing that ring azimuthally
into \code{k} cells. This procedure ensures equal area while allowing the final
segments to adopt compact shapes. In this way, the larger rings become the
final rings, of which there will be \code{n_rings = round(sqrt(n_cells))}.

The final ring containing the zenith has \code{k = 1}, the ring touching the
horizon has \code{k = n_rings}, and the intermediate \code{k} values must be
determined. To impose a compactness structure across zenith angles, the
method uses the equisolid-angle projection:

\deqn{
r = 2 \, f \, \sin\!\left(\frac{\theta}{2}\right)
}

where \eqn{r} is the radial distance, \eqn{f} is the focal length, and
\eqn{\theta} is the zenith angle. Based on this transformation, the
expression \code{round(2 * sin(theta / 2) * n_rings * x)} is used to compute \code{k},
with \code{x} being a scalar (estimated with \code{optim()}) that adjusts the sum of
\code{k} values to exactly match \code{n_cells}.

Because the true central zenith angles of the final rings are not known in
advance (because they depend on \code{k}) the procedure is iterated.
It starts by assuming rings of equal angular width to obtain provisional
central zenith angles, computes \code{k}, updates the ring boundaries from the
resulting grouping, recomputes the central zenith angles, and repeats until
convergence.
}
\examples{
\dontrun{
z <- zenith_image(500, lens())
a <- azimuth_image(500, lens())
seg <- equalarea_segmentation(z, a, n_cells = 512)
plot(seg)
}
}
\seealso{
\code{\link[=skygrid_segmentation]{skygrid_segmentation()}}
}
