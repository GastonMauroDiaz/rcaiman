% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate_sky_points.R
\name{interpolate_sky_points}
\alias{interpolate_sky_points}
\title{Interpolate sky points}
\usage{
interpolate_sky_points(sky_points, g, k = 3, p = 2, rmax = 200)
}
\arguments{
\item{sky_points}{The \emph{data.frame} returned by \code{\link{extract_rl}}
or a \emph{data.frame} with same structure and names.}

\item{g}{\linkS4class{SpatRaster} built with
\code{\link{sky_grid_segmentation}}.}

\item{k}{integer. Number of k-nearest neighbours. Default 10.}

\item{p}{numeric. Power for inverse-distance weighting. Default 2.}

\item{rmax}{numeric. Maximum radius where to search for knn. Default 50.}
}
\value{
An object of class \linkS4class{SpatRaster}.
}
\description{
Interpolate values from hemispherical photographs.
}
\details{
This function use \code{\link[lidR]{knnidw}} as workhorse function, so
arguments \code{k}, \code{p}, and \code{rmax} are passed to it.

This method is based on \insertCite{Lang2010;textual}{rcaiman}. In theory,
interpolation requires a linear relation between DNs and the amount of light
reaching the sensor. To that end, photographs should be taken in RAW format
to avoid gamma correction \insertCite{Lang2010}{rcaiman}. As a compromise
solution, \code{\link{gbc}} can be used.

The vignetting effect also hinders the linear relation between DNs and the
amount of light reaching the sensor. Please refer to
\insertCite{Lang2010;textual}{rcaiman} for more details about the vignetting
effect.

The use of \code{k = 1} solves the linear dilemma from the theoretical point
of view since no averaging is taking place in the calculations. However,
probably, it is best to use \code{k} greater than 1.

Default parameters are the ones used by
\insertCite{Lang2010;textual}{rcaiman}. The argument \code{rmax} should
account for between 15 to 20 degrees, but it is expressed in pixels units. So,
image resolution and lens projections should be taken into account to
set this argument properly.

The argument \code{g} should be the same used to obtain \code{sky_points}.
The result will be limited to the cells with at least one pixel covered by
the convex hull of the sky points.
}
\examples{
\dontrun{
caim <- read_caim() \%>\% normalize()
z <- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a <- azimuth_image(z)
sky_blue_sample <- crop(caim, ext(610,643,760,806))
sky_blue <- apply(sky_blue_sample[], 2, median) \%>\%
  as.numeric() \%>\%
  matrix(., ncol = 3) \%>\%
  sRGB()
ecaim <- enhance_caim(caim, !is.na(z), sky_blue, gamma = 2.2)
bin <- apply_thr(ecaim, 0.75)

g <- sky_grid_segmentation(z, a, 10)
r <- gbc(caim$Blue*255)
sky_points <- extract_sky_points(r, bin, g)
sky_points <- extract_rl(r, z, a, sky_points, NULL)
sky <- interpolate_sky_points(sky_points$sky_points, g)
plot(sky)
}
}
\references{
\insertAllCited{}
}
\seealso{
Other Sky Reconstruction Functions: 
\code{\link{cie_sky_model_raster}()},
\code{\link{fit_cie_sky_model}()},
\code{\link{fit_coneshaped_model}()},
\code{\link{fit_trend_surface}()},
\code{\link{fix_reconstructed_sky}()},
\code{\link{ootb_sky_reconstruction}()}
}
\concept{Sky Reconstruction Functions}
