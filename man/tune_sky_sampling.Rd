% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_sky_sampling.R
\name{tune_sky_sampling}
\alias{tune_sky_sampling}
\title{Tune sky-sampling parameters}
\usage{
tune_sky_sampling(
  r,
  z,
  a,
  equalarea_seg,
  bin_list,
  n_cells_seq,
  dist_to_black_seq,
  w = 0.5,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically the blue
band of a canopy photograph. Digital numbers should be linearly related to
radiance.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{equalarea_seg}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=equalarea_segmentation]{equalarea_segmentation()}}.}

\item{bin_list}{list of logical \link[terra:SpatRaster-class]{terra::SpatRaster} objects of one
layer. Each element is a binarization of \code{r}.}

\item{n_cells_seq}{numeric vector. Sequence of integers to evaluate for
\code{n_cells}.}

\item{dist_to_black_seq}{numeric vector. Sequence of integers to evaluate for
\code{dist_to_black}.}

\item{w}{numeric vector of length one. Weight controlling the balance between
coverage and accuracy (see \emph{Details}).}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with the following components:
\describe{
\item{\code{n_cells}}{Optimal value within \code{n_cells_seq}.}
\item{\code{dist_to_black}}{Optimal value within \code{dist_to_black_seq}.}
\item{\code{bin_list_index}}{Index of the optimal binarization in \code{bin_list}.}
\item{\code{accuracy}}{Numeric. Median of local CV values (MAD / median) at the
sampled sky points. Lower is better.}
\item{\code{coverage}}{Numeric in \eqn{[0,1]}. Fraction of reference cells with
at least one sampled sky point. Higher is better.}
\item{\code{cam}}{Numeric. Minimum Coverage–Accuracy Metric (CAM) for the
selected combination.}
}
}
\description{
Tune the parameters of \code{\link[=extract_sky_pixels]{extract_sky_pixels()}}.
}
\details{
Evaluate combinations of three discrete parameters for sampling sky digital
numbers (\eqn{\delta_\text{sky}}) using \code{\link[=extract_sky_points]{extract_sky_points()}}:
\itemize{
\item the binarized image selected from \code{bin_list}, provided to
\code{\link[=extract_sky_points]{extract_sky_points()}} as argument \code{bin};
\item the parameter \code{n_cells} used to generate a segmentation with
\code{\link[=equalarea_segmentation]{equalarea_segmentation()}}, provided to \code{\link[=extract_sky_points]{extract_sky_points()}} via \code{seg};
\item the minimum allowed distance to black pixels in the binarized image,
provided as argument \code{dist_to_black} of \code{\link[=extract_sky_points]{extract_sky_points()}}.
}

The optimal combination minimizes the Coverage–Accuracy Metric (CAM):

\deqn{\mathrm{CAM} = (1 - \mathrm{coverage}) \cdot w \;+\; \mathrm{accuracy} \cdot (1 - w)}

CAM balances hemispherical surface coverage and the local accuracy of sampled
\eqn{\delta_\text{sky}}, with \eqn{w} acting as a weight that allows the user
to prioritize one component over the other.

True sky regions typically exhibit smooth radiance gradients, in contrast with
bright canopy elements or mixed pixels, which introduce sharper local
fluctuations. To capture this contrast, accuracy is estimated using a
robust local coefficient of variation computed per sample window as
\eqn{\mathrm{CV}_{\text{local}} = \mathrm{MAD}_{3\times3} / \mathrm{median}_{3\times3}},
where MAD and median are calculated on a \eqn{3 \times 3} neighborhood.
The accuracy reported by the function is the median of these local CV values
across the sampled sky points.

Coverage is computed with \code{\link[=assess_sampling_uniformity]{assess_sampling_uniformity()}}, i.e., the fraction
of cells in \code{equalarea_seg} containing at least one sky point.

Lower CAM values indicate lower local variability and higher angular coverage.
}
\examples{
\dontrun{
caim <- read_caim()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
r <- caim$Blue

seg <- equalarea_segmentation(z, a, 30)
bin_list <- lapply(c("thr_twocorner", "thr_isodata"),
                   function(x) {
                     binarize_by_region(r, seg, x) & select_sky_region(z, 0, 88)
                   })

equalarea_seg <- equalarea_segmentation(z, a, 10)
params <- tune_sky_sampling(r, z, a,
                            equalarea_seg,
                            bin_list,
                            n_cells_seq = seq(100, 500, 100),
                            dist_to_black_seq = 1:10,
                            w = 0.5,
                            parallel = TRUE)

sky_points <- extract_sky_points(r,
                                 bin_list[[params$bin_list_index]],
                                 equalarea_segmentation(z, a, params$n_cells),
                                 params$dist_to_black)
display_caim(caim$Blue, sky_points = sky_points)
}
}
