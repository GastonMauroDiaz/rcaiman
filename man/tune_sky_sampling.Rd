% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_sky_sampling.R
\name{tune_sky_sampling}
\alias{tune_sky_sampling}
\title{Tune sky-sampling parameters}
\usage{
tune_sky_sampling(
  r,
  z,
  a,
  equalarea_seg,
  bin_list,
  n_cells_seq,
  dist_to_black_seq,
  w = 0.5,
  write_log_in = NULL,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically the blue
band of a canopy photograph. Digital numbers should be linearly related to
radiance.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{equalarea_seg}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=equalarea_segmentation]{equalarea_segmentation()}}.}

\item{bin_list}{list of logical \link[terra:SpatRaster-class]{terra::SpatRaster} objects of one
layer. Each element is a binarization of \code{r}.}

\item{n_cells_seq}{numeric vector. Sequence of integers to evaluate for
\code{n_cells}.}

\item{dist_to_black_seq}{numeric vector. Sequence of integers to evaluate for
\code{dist_to_black}.}

\item{w}{numeric vector of length one. Weight controlling the balance between
coverage and accuracy (see \emph{Details}).}

\item{write_log_in}{Character path (without extension) used to generate
two output files summarizing the tuning run. See \emph{Details}.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with the following numeric vectors of length one:
\describe{
\item{\code{n_cells}}{Optimal value within \code{n_cells_seq}.}
\item{\code{dist_to_black}}{Optimal value within \code{dist_to_black_seq}.}
\item{\code{bin_list_index}}{Index of the optimal binarization in \code{bin_list}.}
\item{\code{accuracy}}{Median of local CV values (MAD / median) at the
sampled sky points. Lower is better.}
\item{\code{coverage}}{Fraction of reference cells with
at least one sampled sky point. Higher is better.}
\item{\code{cam}}{Minimum Coverage-Accuracy Metric (CAM) for the
selected combination.}
}
}
\description{
Tune the parameters of \code{\link[=sample_sky_points]{sample_sky_points()}}.
}
\details{
This function evaluates combinations of three discrete parameters for sampling
sky digital numbers (\eqn{\delta_\text{sky}}) using
\code{\link[=sample_sky_points]{sample_sky_points()}}:
\itemize{
\item the binarized image selected from \code{bin_list}, provided as argument
\code{bin};
\item the parameter \code{n_cells} used to generate a segmentation with
\code{\link[=equalarea_segmentation]{equalarea_segmentation()}}, provided as argument \code{seg};
\item the minimum allowed distance to black pixels in the binarized image,
provided as argument \code{dist_to_black}.
}

Two criteria are computed for each parameter combination:
\itemize{
\item \emph{accuracy}, estimated from the local variability of
\eqn{\delta_\text{sky}};
\item \emph{coverage}, the fraction of equal-area cells containing at least one
sampled sky point.
}

The computation of these criteria is described below, together with their
normalization and the construction of the final comparison metric.

\describe{
\item{\emph{Accuracy estimation}}{
True sky regions tend to show smooth radiance gradients, whereas bright
canopy elements or mixed pixels introduce stronger local fluctuations.
Accuracy is therefore quantified with a robust local coefficient of
variation computed by \code{\link[=extract_cv]{extract_cv()}}. For each parameter combination, the
final accuracy value is the median of these local CV estimates across all
sampled sky points.
}
\item{\emph{Coverage estimation}}{
Coverage is computed with \code{\link[=assess_sampling_uniformity]{assess_sampling_uniformity()}}, i.e., the
fraction of cells in \code{equalarea_seg} that contain at least one sky point.
}
\item{\emph{Scaling of components}}{
Because the magnitudes of accuracy and coverage may differ substantially
across the parameter grid, both components are rescaled to \eqn{[0,1]} using
\code{\link[=normalize_minmax]{normalize_minmax()}}. This ensures that the relative contribution of each
component to the optimization reflects the balance specified by \eqn{w}
rather than artifacts of scale.
}
\item{\emph{Coverage-Accuracy Metric (CAM)}}{
After normalization, the Coverage-Accuracy Metric is defined as:

\deqn{
   \mathrm{CAM} =
   (1 - \mathrm{coverage}_n) \cdot w
   \;+\;
   \mathrm{accuracy}_n \cdot (1 - w) \; ,
   }

were \eqn{n} is the nth parameter combination being tested.

Lower CAM values indicate parameter combinations that achieve both high
hemispherical coverage and low local radiance variability at the sampled sky
points. The function returns the combination that minimizes CAM.
}
}
}
\section{Write one disk (optional)}{


If \code{write_log_in} is not \code{NULL}, the function writes:

\describe{
\item{\verb{<write_log_in>_tune_log.txt}}{A human-readable log containing timestamps,
elapsed time (minutes), system information, the tested parameters,
the selected combination, and its performance metrics.}
\item{\verb{<write_log_in>_tune_metrics.csv}}{A tabular file listing all tested
parameter combinations (\code{params}) together with their associated
metrics. Load it with \code{\link[utils:read.table]{utils::read.csv2()}} and use \code{\link[=which.min]{which.min()}} to
retrieve the best parameters}
}
If \code{NULL}, no files are written.
}

\examples{
\dontrun{
caim <- read_caim()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
r <- caim$Blue

seg <- equalarea_segmentation(z, a, 30)
bin_list <- lapply(c("thr_twocorner", "thr_isodata"),
                   function(x) {
                     binarize_by_region(r, seg, x) & select_sky_region(z, 0, 88)
                   })

equalarea_seg <- equalarea_segmentation(z, a, 10)
params <- tune_sky_sampling(r, z, a,
                            equalarea_seg,
                            bin_list,
                            n_cells_seq = seq(100, 500, 100),
                            dist_to_black_seq = 1:10,
                            w = 0.5,
                            parallel = TRUE)

sky_points <- sample_sky_points(r,
                                bin_list[[params$bin_list_index]],
                                equalarea_segmentation(z, a, params$n_cells),
                                params$dist_to_black)
display_caim(caim$Blue, sky_points = sky_points)
}
}
