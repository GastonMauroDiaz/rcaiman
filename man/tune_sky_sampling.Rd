% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune_sky_sampling.R
\name{tune_sky_sampling}
\alias{tune_sky_sampling}
\title{Tune sky-sampling parameters}
\usage{
tune_sky_sampling(
  r,
  z,
  a,
  bin,
  n_cells_seq,
  dist_to_black_seq,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically the blue
band of a canopy photograph. Digital numbers must be linearly related to
radiance. See \code{\link[=read_caim_raw]{read_caim_raw()}} for details.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{bin}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binarized
hemispherical image. See \code{\link[=binarize_with_thr]{binarize_with_thr()}} for details.}

\item{n_cells_seq}{numeric vector. Sequence of integer values to evaluate for
\code{n_cells}.}

\item{dist_to_black_seq}{numeric vector. Sequence of integer values to
evaluate for \code{dist_to_black}.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with three components:
\describe{
\item{\code{n_cells}}{Optimal value within \code{n_cells_seq}.}
\item{\code{dist_to_black}}{Optimal value within \code{dist_to_black_seq}.}
\item{\code{metric}}{Minimum composite metric.}
}
}
\description{
Evaluate combinations of two discrete parameters governing sky-point
extraction: the number of equal-area sky segments (\code{n_cells}) and the minimum
allowed distance to the binarized canopy (\code{dist_to_black}).
For each parameter pair, the function computes a composite performance metric
combining (i) angular uniformity relative to a reference segmentation and
(ii) local sky variability (CV) derived from the original image.
The pair with the lowest metric is selected.
}
\details{
Each combination (\code{n_cells}, \code{dist_to_black}) is evaluated by:
\enumerate{
\item generating an equal-area segmentation with \code{n_cells};
\item extracting one representative sky point per cell, subject to the
minimum distance to pixels classified as non-sky;
\item computing two indicators:
(a) median local sky CV,
(b) angular uniformity (KL divergence) relative to a fixed reference
equal-area segmentation.
}

The final metric is the mean of the two indicators, expressed on comparable
relative scales.

When \code{parallel = TRUE}, the function reconstructs spatial objects inside each
worker to reduce communication overhead and ensure independence across
parallel tasks.
}
\examples{
\dontrun{
caim <- read_caim()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
r <- caim$Blue

seg <- equalarea_segmentation(z, a, 30)
bin <- binarize_by_region(r, seg, "thr_twocorner") & select_sky_region(z, 0, 88)

params <- tune_sky_sampling(r, z, a, bin, seq(100, 800, 50), 1:10)

seg <- equalarea_segmentation(z, a, params$n_cells)
sky_points <- extract_sky_points(r, bin, seg, params$dist_to_black)
display_caim(caim$Blue, sky_points = sky_points)
}
}
