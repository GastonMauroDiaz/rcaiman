% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expand_sky_points.R
\name{expand_sky_points}
\alias{expand_sky_points}
\title{Expand sky points}
\usage{
expand_sky_points(
  r,
  z,
  a,
  sky_points,
  angle_width = 3,
  k = 20,
  p = 2,
  rmax = 20
)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see \code{\link[=read_caim]{read_caim()}}
and \code{\link[=normalize]{normalize()}}.}

\item{z}{\linkS4class{SpatRaster} built with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\linkS4class{SpatRaster} built with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{sky_points}{An object of class \emph{data.frame}. The output of
\code{\link[=extract_sky_points]{extract_sky_points()}}. As an alternative, both
\href{https://imagej.net/ij/}{ImageJ} and HSP software package
\insertCite{Lang2013}{rcaiman} can be used to manually digitize points. See
\code{\link[=extract_dn]{extract_dn()}} and \code{\link[=read_manual_input]{read_manual_input()}} for details.}

\item{angle_width}{Numeric vector of length one. It should be \verb{30, 15, 10, 7.5, 6, 5, 3.75, 3, 2.5, 1.875, 1} or \code{0.5} degrees. This
constrain is rooted in the requirement of a value able to divide both the
\code{0} to \code{360} and \code{0} to \code{90} ranges into a whole number
of segments.}

\item{k}{Numeric vector of length one. Number of k-nearest neighbors.}

\item{p}{Numeric vector of length one. Power for inverse-distance weighting.}

\item{rmax}{Numeric vector of length one. The maximum radius for searching
k-nearest neighbors (knn). Points are projected onto a unit-radius sphere,
similar to the use of relative radius in image mapping. The spherical
distance is then calculated and used to filter out points farther than
\code{rmax}.The distance is expressed in degrees. If an insufficient number of
neighbors are found within the search radius, the point is retained due to
a lack of evidence for removal.}
}
\value{
An object of the class \emph{data.frame}. It is the input argument
\code{sky_points} with the following additional data:
\itemize{
\item Rows resulting of interpolating the \code{sky_points} argument.
\item Columns \emph{a}, \emph{z}, \emph{dn}, and \emph{initial}.
\itemize{
\item \emph{a}, the azimuthal angle.
\item \emph{z}:, the zenithal angle.
\item \emph{dn}, the digital number.
\item \emph{initial}, if 'TRUE' the point is from the \code{sky_points} argument.
}
}
}
\description{
Expand sky points using a \emph{k} neharest neightbord approach
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
bin <- apply_thr(r, thr_isodata(r[]))
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)

# See fit_cie_sky_model() for details on the CSV file
path <- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points <- read.csv(path)
sky_points <- sky_points[c("Y", "X")]
colnames(sky_points) <- c("row", "col")
head(sky_points)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

sky_points2 <- expand_sky_points(r, z, a, sky_points, angle_width = 5)
plot(bin)
points(sky_points2$col, nrow(caim) - sky_points2$row, col = 2, pch = 10)
}
}
\seealso{
Other Tool Functions: 
\code{\link{calc_oor_index}()},
\code{\link{calc_sngd}()},
\code{\link{colorfulness}()},
\code{\link{correct_vignetting}()},
\code{\link{defuzzify}()},
\code{\link{extract_dn}()},
\code{\link{extract_feature}()},
\code{\link{extract_rl}()},
\code{\link{extract_sky_points}()},
\code{\link{extract_sun_coord}()},
\code{\link{find_general_sky_type}()},
\code{\link{find_sky_pixels}()},
\code{\link{masking}()},
\code{\link{optim_normalize}()},
\code{\link{percentage_of_clipped_highlights}()},
\code{\link{read_bin}()},
\code{\link{read_caim}()},
\code{\link{read_caim_raw}()},
\code{\link{read_ootb_sky_model}()},
\code{\link{sor_filter}()},
\code{\link{write_bin}()},
\code{\link{write_caim}()},
\code{\link{write_ootb_sky_model}()}
}
\concept{Tool Functions}
