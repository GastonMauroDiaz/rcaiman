% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ootb_cie_model.R
\name{ootb_cie_model}
\alias{ootb_cie_model}
\title{Out-of-the-box CIE sky model}
\usage{
ootb_cie_model(
  r,
  z,
  a,
  m,
  method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
  parallel = TRUE,
  cores = NULL,
  leave_free = 1,
  logical = TRUE
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically, the blue
band of a a canopy photograph. Digital numbers should be linearly related
to radiance. See \code{\link[=read_caim_raw]{read_caim_raw()}} for details.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{m}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binary mask with
\code{TRUE} for selected pixels.}

\item{method}{character vector. Optimization methods for \code{\link[=fit_cie_model]{fit_cie_model()}}
and \code{\link[=optim_sun_angles]{optim_sun_angles()}}.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}
}
\value{
List with the following components:
\describe{
\item{\code{rr}}{The input \code{rr} with an added \code{pred} column in
\code{sky_points}, containing predicted values.}
\item{\code{opt_result}}{List returned by \code{\link[stats:optim]{stats::optim()}}.}
\item{\code{coef}}{Numeric vector of length five. CIE model coefficients.}
\item{\code{sun_angles}}{Numeric vector of length two. Sun zenith and azimuth
(degrees).}
\item{\code{method}}{Character vector of length one. Optimization method used.}
\item{\code{start}}{Numeric vector of length five. Starting parameters.}
\item{\code{metric}}{Numeric value. Mean squared deviation as in
\insertCite{Gauch2003;textual}{rcaiman}.}
\item{\code{method_sun}}{Character vector of length one or \code{NULL}.
Method used to optimice sun angles.}
}
}
\description{
Fit a CIE general sky model to data obtained from a canopy image with an
histogram-based method.
}
\note{
This function is part of a paper under preparation.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

model <- ootb_cie_model(r, z, a, m)

plot(model$rr$sky_points$rr, model$rr$sky_points$pred)
abline(0,1)
lm(model$rr$sky_points$pred~model$rr$sky_points$rr) \%>\% summary()

sky <- cie_image(z, a, model$sun_angles, model$coef) * model$rr$zenith_dn
plot(sky)
ratio <- r/sky
plot(ratio)
plot(ratio > 1.05)
plot(ratio > 1.15)
}
}
