% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assess_sampling_uniformity.R
\name{assess_sampling_uniformity}
\alias{assess_sampling_uniformity}
\title{Assess sampling uniformity}
\usage{
assess_sampling_uniformity(sky_points, equalarea_seg)
}
\arguments{
\item{sky_points}{\code{data.frame} with columns \code{row} and \code{col} (raster
coordinates).}

\item{equalarea_seg}{single-layer \link[terra:SpatRaster-class]{terra::SpatRaster} with integer values. Sky
segmentation map produced by \code{\link[=equalarea_segmentation]{equalarea_segmentation()}}.}
}
\value{
Numeric vector of length one. Kullback–Leibler divergence from uniformity.
}
\description{
Quantify how uniformly a set of sky sampling points covers the hemispherical
domain with the Kullback–Leibler divergence.
}
\details{
The method projects the input points onto an equal–area grid
(\code{equalarea_seg}), computes empirical cell frequencies, and
evaluates the resulting discrete distribution against a uniform target.

Let \code{N} be the number of valid cells and \code{c_i} the count in cell \code{i}.
The empirical distribution is
\deqn{p_i = \frac{c_i}{\sum_{j=1}^N c_j}.}

The uniform reference is
\deqn{u_i = \frac{1}{N}.}

Kullback–Leibler divergence from uniformity is
\deqn{\mathrm{KL}(p\|u) = \sum_i p_i \log(p_i N).}
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

seg <- equalarea_segmentation(z, a, 20)
bin <- binarize_by_region(r, seg, method = "thr_twocorner")
bin <- bin & select_sky_region(z, 0, 80)

g <- skygrid_segmentation(z, a, 5, first_ring_different = TRUE)
sky_points <- extract_sky_points(r, bin, g, dist_to_black = 3)
plot(r)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

n_cells <- extract_dn(bin, fibonacci_points(z, a, 1), use_window = FALSE)[,3] \%>\% sum()
seg <- equalarea_segmentation(z, a, n_cells)
kl <- assess_sampling_uniformity(sky_points, seg)

seg <- equalarea_segmentation(z, a, 200)
kl <- lapply(1:30, function(i) {
  sky_points <-  rem_nearby_points(sky_points, NULL, z, a, i, space = "spherical")
  assess_sampling_uniformity(sky_points, seg)
})
plot(unlist(kl))
}
}
