% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate_and_merge.R
\name{interpolate_and_merge}
\alias{interpolate_and_merge}
\title{Interpolate sky data into a raster and merge it with a sky model raster}
\usage{
interpolate_and_merge(r, z, a, sky_points, ootb_sky, expand = TRUE)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see \code{\link[=read_caim]{read_caim()}}
and \code{\link[=normalize]{normalize()}}.}

\item{z}{\linkS4class{SpatRaster} built with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\linkS4class{SpatRaster} built with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{sky_points}{An object of class \emph{data.frame}. The result of a call to
\code{\link[=extract_sky_points]{extract_sky_points()}}. As an alternative, both
\href{https://imagej.net/ij/}{ImageJ} and HSP software package
\insertCite{Lang2013}{rcaiman} can be used to manually digitize points. See
\code{\link[=extract_dn]{extract_dn()}} and \code{\link[=read_manual_input]{read_manual_input()}} for details.}

\item{ootb_sky}{An object of the class \code{list} that is the result of calling
\code{\link[=ootb_sky_reconstruction]{ootb_sky_reconstruction()}}.}

\item{expand}{Logical vector of length one. If \code{TRUE}, \code{\link[=expand_sky_points]{expand_sky_points()}}
will be applied internally.}
}
\value{
An object of class \linkS4class{SpatRaster}.
}
\description{
This function is part of the efforts to automate the method proposed by
\insertCite{Lang2010;textual}{rcaiman}. See \code{\link[=ootb_sky_reconstruction]{ootb_sky_reconstruction()}} for
further details.
}
\examples{
\dontrun{
caim <- read_caim()
bsi <- (caim$Blue-caim$Red) / (caim$Blue+caim$Red)

z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

r <- caim$Blue

bin <- regional_thresholding(r, rings_segmentation(z, 30),
                             method = "thr_isodata")
g <- sky_grid_segmentation(z, a, 10)
sun_coord <- extract_sun_coord(r, z, a, bin, g)
sun_coord$zenith_azimuth

.a <- azimuth_image(z, orientation = sun_coord$zenith_azimuth[2]+90)
seg <- sectors_segmentation(.a, 180) * rings_segmentation(z, 30)
bin <- regional_thresholding(r, seg, method = "thr_isodata")

mx <- optim_normalize(caim, bin)
caim <- normalize(caim, mx = mx, force_range = TRUE)
ecaim <- enhance_caim(caim, m, HSV(239, 0.85, 0.5))
bin <- apply_thr(ecaim, thr_isodata(ecaim[m])) & bsi > 0.1

set.seed(7)
g <- sky_grid_segmentation(z, a, 10, first_ring_different = TRUE)
sky <- ootb_sky_reconstruction(r, z, a, m, bin & mask_hs(z, 0, 80), g,
                               sor_filter_cv = TRUE, sor_filter_dn = TRUE,
                               min_spherical_dist = 3)

ratio <- r/sky$sky
.r <- normalize(ecaim *
                  normalize(ratio, 0, 1, TRUE) * normalize(bsi, 0, 1, TRUE))
bin <- apply_thr(.r, thr_isodata(.r[m]))

g <- sky_grid_segmentation(z, a, 5, first_ring_different = TRUE)
sky_points <- extract_sky_points(r, bin, g, dist_to_plant = 3,
                                 min_raster_dist = 9)

plot(bin)
points(sky$sky_points$col, nrow(caim) - sky$sky_points$row, col = 2, pch = 10)
points(sky_points$col, nrow(caim) - sky_points$row, col = 4, pch = 10)

plot(sky$sky)
sky2 <- interpolate_and_merge(r, z, a, sky_points, sky)
plot(sky2)
calc_oor_index(r, sky2)
sky$oor_index
}
}
\references{
\insertAllCited{}
}
\seealso{
Other Sky Reconstruction Functions: 
\code{\link{cie_sky_model_raster}()},
\code{\link{fit_cie_sky_model}()},
\code{\link{fit_coneshaped_model}()},
\code{\link{fit_trend_surface}()},
\code{\link{interpolate_sky_points}()},
\code{\link{ootb_sky_reconstruction}()}
}
\concept{Sky Reconstruction Functions}
