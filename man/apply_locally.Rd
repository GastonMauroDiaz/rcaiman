% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_locally.R
\name{apply_locally}
\alias{apply_locally}
\title{Apply a function locally using sampled points on the hemispherical domain}
\usage{
apply_locally(
  sampling_points,
  query_points = NULL,
  z,
  a,
  k = 20,
  angular_radius = 20,
  rule = "any",
  fun,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{sampling_points}{data.frame with columns \code{row} and \code{col}. Source points used
as candidate neighbors.}

\item{query_points}{optional data.frame with columns \code{row} and
\code{col} with the points at which \code{fun} should be evaluated.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{k}{numeric vector of length one. Number of neighbors.}

\item{angular_radius}{numeric vector of length one. The maximum radius for
searching k-nearest neighbors (KNN) in degrees.}

\item{rule}{character vector of length one. \code{"any"} or \code{"all"}. See \emph{Details}.}

\item{fun}{function. Must accept a data.frame (subset of \code{sampling_points}) and
return a numeric scalar.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
A data.frame equal to \code{query_points} with one additional column, named
\code{"out"}, containing the result of applying \code{fun} at each query point.
}
\description{
Evaluate a user-supplied function locally using neighboring points
defined on the hemispherical domain.
}
\details{
The \code{query_points} argument lets the user evaluate \code{fun} at a custom set of
locations. For each point in \code{query_points}, neighbors are searched within
\code{sampling_points}. When \code{query_points} is \code{NULL} (default), the evaluation is
performed for every point in \code{sampling_points}. Neighbor selection is based on
spherical distance, see \code{\link[=calc_spherical_distance]{calc_spherical_distance()}}. The function \code{fun} is
then applied to the corresponding subset of neighboring sampling points.

The input passed to \code{fun} is a \strong{subset of rows of \code{sampling_points}}, therefore,
\code{fun} must extract and process the column(s) of interest, e.g.: \code{function(df) mean(df$dn)}.

The angular neighborhood is defined by two parameters:
\itemize{
\item \code{k}: number of nearest neighbors used by \code{fun}.
\item \code{angular_radius}: maximum allowed spherical distance (deg).
}

Argument \code{rule} controls how neighbor availability is interpreted:
\itemize{
\item \code{"any"}: all neighbors found within \code{angular_radius} are passed to \code{fun}
(even if fewer than \code{k}).
\item \code{"all"}: if fewer than \code{k} neighbors lie within the radius, the query
point is assigned \code{NA}.
}
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)

# local thresholding
sampling_points <- fibonacci_points(z, a, 3)
display_caim(caim, sampling_points = sampling_points)
sampling_points <- extract_dn(r, sampling_points, use_window = FALSE)
head(sampling_points)
eval_points <- apply_locally(
  sampling_points,
  fibonacci_points(z, a, 10),
  z,
  a,
  k = 500,
  angular_radius = 30,
  rule = "any",
  fun = function(df) thr_isodata(df$Blue)
)

thr <- triangulate(eval_points[!is.na(eval_points$out),], r, col_id = 3)
plot(thr)
plot(binarize_with_thr(r, thr))

# Detect background DN
sampling_points <- fibonacci_points(z, a, 2)
sampling_points <- extract_dn(r, sampling_points, use_window = FALSE)
query_points <- fibonacci_points(z, a, 10)
eval_points <- apply_locally(
  sampling_points,
  query_points,
  z,
  a,
  k = 1000,
  angular_radius = 40,
  rule = "any",
  fun = function(df) {
    tryCatch(thr_twocorner(df[,3])$up, error = function(e) NA)
  },
  parallel = TRUE
)
i <- !is.na(eval_points$out)

sky <- triangulate(eval_points[i, ], r, col_id = 3)
plot(sky)
plot(r/sky)

}
}
\seealso{
\code{\link[=skygrid_centers]{skygrid_centers()}} and \code{\link[=fibonacci_points]{fibonacci_points()}} for producing \code{query_points}.
}
