% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ootb_sky_cie.R
\name{ootb_sky_cie}
\alias{ootb_sky_cie}
\title{Out-of-the-box CIE sky model and raster}
\usage{
ootb_sky_cie(
  r,
  z,
  a,
  m,
  bin,
  equalarea_seg,
  seg,
  dist_to_black,
  method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
  sun_disk_mode = c("obscured", "veiled", "twilight"),
  custom_sky_coef = NULL,
  std_sky_no = NULL,
  general_sky_type = NULL,
  optim_zenith_dn = TRUE,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically the blue
band of a canopy photograph. Digital numbers should be linearly related to
radiance.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{m}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binary mask with
\code{TRUE} for selected pixels.}

\item{bin}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binarized
hemispherical image. See \code{\link[=binarize_with_thr]{binarize_with_thr()}} for details.}

\item{equalarea_seg}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with
\code{\link[=equalarea_segmentation]{equalarea_segmentation()}}. Internally used in \code{\link[=estimate_sun_angles]{estimate_sun_angles()}} and
\code{\link[=optimize_sampling_uniformity]{optimize_sampling_uniformity()}}.}

\item{seg}{single-layer \link[terra:SpatRaster-class]{terra::SpatRaster}. Segmentation map of r,
typically created with functions such as \code{\link[=equalarea_segmentation]{equalarea_segmentation()}}, \code{\link[=skygrid_segmentation]{skygrid_segmentation()}},
\code{\link[=ring_segmentation]{ring_segmentation()}} or \code{\link[=sector_segmentation]{sector_segmentation()}}, but any raster with
integer segment labels is accepted. Ignored when \code{method = "local_max"}.}

\item{dist_to_black}{numeric vector of length one or \code{NULL}. Minimum distance
(pixels) to the nearest black pixel for a candidate sky pixel to be valid.
If \code{NULL}, no distance constraint is applied. Ignored with \code{method = local_max}.}

\item{method}{character vector. Optimization methods passed to
\code{\link[stats:optim]{stats::optim()}}. See that function for supported names.}

\item{sun_disk_mode}{character vector. Estimation modes for the solar disk.
Supported values are \code{"obscured"}, \code{"veiled"}, and \code{"twilight"}. See
\code{\link[=estimate_sun_angles]{estimate_sun_angles()}} for details on the first two. The \code{"twilight"}
mode tests the \code{"obscured"} candidate plus variants where the sun zenith
angle is forced to five values equally spaced between the estimated sun
zenith angle and the horizon, and to values between 90 and 96 deg
(civil twilight).}

\item{custom_sky_coef}{numeric vector of length five, or numeric matrix
with five columns. Custom starting coefficients for optimization.
If not provided, coefficients are initialized from standard skies.}

\item{std_sky_no}{numeric vector. Standard sky numbers as in \link{cie_table}.
If not provided, all are used.}

\item{general_sky_type}{character vector of length one. Must be \code{"Overcast"},
\code{"Clear"}, or \code{"Partly cloudy"}. See column \code{general_sky_type} in
\link{cie_table} for details. If not provided, all sky types are used.}

\item{optim_zenith_dn}{logical vector of length one. See \code{\link[=fit_cie_model]{fit_cie_model()}}
for details.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with:
\describe{
\item{\code{rr}}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster}. Predicted relative radiance.}
\item{\code{model}}{list returned by \code{\link[=fit_cie_model]{fit_cie_model()}}. The optimal fit.}
\item{\code{params}}{list returned by \code{\link[=tune_sky_sampling]{tune_sky_sampling()}}.}
\item{\code{sky_points}}{\code{data.frame} with columns \code{row} and \code{col}. Locations of
sky points.}
\item{\code{sun_row_col}}{\code{data.frame} with the estimated sun‑disk position in
image coordinates.}
\item{\code{optimal_start}}{\code{custom_sky_coef} with the estimated sun‑disk position in
image coordinates.}
}
}
\description{
Fit and validate a CIE general sky model to radiance sampled on canopy
gaps and return the predicted raster.
}
\note{
This function is part of a paper under preparation.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

com <- complementary_gradients(caim)
thr <- thr_twocorner(com$red_cyan[])
bin <- binarize_with_thr(com$red_cyan, thr$uc)
bin <- rem_isolated_black_pixels(bin)
bin_list <- c(bin_list, bin)
bin_list <- c(bin_list, rem_small_gaps(bin))

set.seed(7)
sky_cie <- ootb_sky_cie(r, z, a, m,
                        bin_list,
                        n_cells_seq,
                        dist_to_black_seq,
                        method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
                        twilight = FALSE,
                        std_sky_no = 12,
                        optim_zenith_dn = TRUE,
                        parallel = TRUE)

sky_cie$rr
plot(sky_cie$rr)
plot(sky_cie$model$rr$sky_points$pred, sky_cie$model$rr$sky_points$rr,
     xlab = "Predicted relative radiance", ylab = "Observed relative radiance")
abline(0,1)

ratio <- r/sky_cie$rr/sky_cie$model$rr$zenith_dn
plot(ratio)
plot(select_sky_region(ratio, 0.95, 1.05))
plot(select_sky_region(ratio, 1.05, 100))

display_caim(caim, sky_points = sky_cie$sky_points, sun_row_col = sun)
}
}
