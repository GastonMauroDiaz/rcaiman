% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ootb_sky_cie.R
\name{ootb_sky_cie}
\alias{ootb_sky_cie}
\title{Out-of-the-box CIE sky model and raster}
\usage{
ootb_sky_cie(
  r,
  z,
  a,
  m,
  bin_list,
  n_cells_seq,
  dist_to_black_seq,
  w = 0.5,
  method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
  twilight = FALSE,
  custom_sky_coef = NULL,
  std_sky_no = NULL,
  general_sky_type = NULL,
  optim_zenith_dn = FALSE,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically the blue
band of a canopy photograph. Digital numbers should be linearly related to
radiance.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{m}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binary mask with
\code{TRUE} for selected pixels.}

\item{bin_list}{list of logical \link[terra:SpatRaster-class]{terra::SpatRaster} objects of one
layer. Each element is a binarization of \code{r}.}

\item{n_cells_seq}{numeric vector. Sequence of integers to evaluate for
\code{n_cells}.}

\item{dist_to_black_seq}{numeric vector. Sequence of integers to evaluate for
\code{dist_to_black}.}

\item{w}{numeric vector of length one. Weight controlling the balance between
coverage and accuracy (see \emph{Details}).}

\item{method}{character vector. Optimization methods passed to
\code{\link[stats:optim]{stats::optim()}}. See that function for supported names.}

\item{twilight}{logical vector of length one. When \code{TRUE}, test sun zenith
angles from 90 to 96 deg (civil twilight), plus five additional zenith
angles equally spaced between the estimated sun zenith angle and the
horizon. This is required because \code{\link[=estimate_sun_angles]{estimate_sun_angles()}} with
\code{method = "assume_obscured"} may incorrectly identify the center of the
visible circumsolar region as the solar disk.}

\item{custom_sky_coef}{numeric vector of length five, or numeric matrix
with five columns. Custom starting coefficients for optimization.
If not provided, coefficients are initialized from standard skies.}

\item{std_sky_no}{numeric vector. Standard sky numbers as in \link{cie_table}.
If not provided, all are used.}

\item{general_sky_type}{character vector of length one. Must be \code{"Overcast"},
\code{"Clear"}, or \code{"Partly cloudy"}. See column \code{general_sky_type} in
\link{cie_table} for details. If not provided, all sky types are used.}

\item{optim_zenith_dn}{logical vector of length one. Whether \code{zenith_dn} value
provided via \code{rr} should be optimized.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with:
\describe{
\item{\code{rr_raster}}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster}. Predicted relative radiance.}
\item{\code{model}}{list returned by \code{\link[=fit_cie_model]{fit_cie_model()}}. The optimal fit.}
\item{\code{params}}{list returned by \code{\link[=tune_sky_sampling]{tune_sky_sampling()}}.}
\item{\code{sky_points}}{\code{data.frame} with columns \code{row} and \code{col}. Locations of
sky points.}
\item{\code{sun_row_col}}{\code{data.frame} with the estimated sun‑disk position in
image coordinates.}
\item{\code{optimal_start}}{\code{custom_sky_coef} with the estimated sun‑disk position in
image coordinates.}
}
}
\description{
Fit and validate a CIE general sky model to radiance sampled on canopy
gaps and return the predicted raster.
}
\note{
This function is part of a paper under preparation.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

com <- complementary_gradients(caim)
thr <- thr_twocorner(com$red_cyan[])
bin <- binarize_with_thr(com$red_cyan, thr$uc)
bin <- rem_isolated_black_pixels(bin)
bin_list <- c(bin_list, bin)
bin_list <- c(bin_list, rem_small_gaps(bin))

set.seed(7)
sky_cie <- ootb_sky_cie(r, z, a, m,
                        bin_list,
                        n_cells_seq,
                        dist_to_black_seq,
                        method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
                        twilight = FALSE,
                        std_sky_no = 12,
                        optim_zenith_dn = TRUE,
                        parallel = TRUE)

sky_cie$rr_raster
plot(sky_cie$rr_raster)
plot(sky_cie$model$rr$sky_points$pred, sky_cie$model$rr$sky_points$rr,
     xlab = "Predicted relative radiance", ylab = "Observed relative radiance")
abline(0,1)

ratio <- r/sky_cie$rr_raster/sky_cie$model$rr$zenith_dn
plot(ratio)
plot(select_sky_region(ratio, 0.95, 1.05))
plot(select_sky_region(ratio, 1.05, 100))

display_caim(caim, sky_points = sky_cie$sky_points, sun_row_col = sun)
}
}
