% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ootb_sky_cie.R
\name{ootb_sky_cie}
\alias{ootb_sky_cie}
\title{Out-of-the-box CIE sky model and raster}
\usage{
ootb_sky_cie(
  r,
  z,
  a,
  m,
  bin,
  gs,
  min_spherical_dist = seq(0, 12, 3),
  method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
  custom_sky_coef = NULL,
  parallel = TRUE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} of one layer. Typically, the blue
band of a a canopy photograph. Digital numbers should be linearly related
to radiance. See \code{\link[=read_caim_raw]{read_caim_raw()}} for details.}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{m}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binary mask with
\code{TRUE} for selected pixels.}

\item{bin}{logical \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. A binarized
hemispherical image. See \code{\link[=binarize_with_thr]{binarize_with_thr()}} for details.}

\item{gs}{\code{list} where each element is the output of
\code{\link[=sky_grid_segmentation]{sky_grid_segmentation()}}. See \emph{Examples} for guidance.}

\item{min_spherical_dist}{numeric vector. Values passed to
\code{\link[=rem_nearby_points]{rem_nearby_points()}}.}

\item{method}{character vector. Optimization methods for \code{\link[=fit_cie_model]{fit_cie_model()}}
and \code{\link[=optim_sun_angles]{optim_sun_angles()}}.}

\item{custom_sky_coef}{optional numeric vector of length five. If \code{NULL}
(default), the 15 standard CIE skies are tested as starting
conditions. Specific standard CIE sky or skies can be provided with
\code{as.numeric(cie_table[i,  1:5])}, where \code{i} must be a numeric vector with
values between 1 and 15. Coefficients can also be obtained with
\code{\link[=ootb_cie_model]{ootb_cie_model()}}.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
List with:
\describe{
\item{\code{rr_raster}}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster}. Predicted relative radiance.}
\item{\code{model}}{list returned by \code{\link[=fit_cie_model]{fit_cie_model()}}. The optimal fit.}
\item{\code{model_validation}}{list returned by \code{\link[=validate_cie_model]{validate_cie_model()}}.}
\item{\code{dist_to_black}}{Value of \code{dist_to_black} used in \code{\link[=extract_sky_points]{extract_sky_points()}}
for the optimal fit.}
\item{\code{use_window}}{\code{logical}. Whether a window was used in \code{\link[=extract_rr]{extract_rr()}}
for the optimal fit.}
\item{\code{min_spherical_dist}}{Value of \code{min_dist} used in
\code{rem_nearby_points(space = "spherical")} for the optimal fit.}
\item{\code{sky_points}}{\code{data.frame} with columns \code{row} and \code{col}. Locations of
sky points.}
\item{\code{sun_row_col}}{\code{data.frame} with the estimated sunâ€‘disk position in
image coordinates.}
\item{\code{g}}{Sky grid used for the optimal fit (as returned by \code{\link[=sky_grid_segmentation]{sky_grid_segmentation()}}).}
\item{\code{tested_grids}}{character vector describing the tested grid configurations.}
\item{\code{tested_distances}}{character vector of tested \code{min_dist} values in
\code{rem_nearby_points(space = "spherical")}.}
\item{\code{tested_methods}}{character vector of optimization methods tested in
\code{\link[=fit_cie_model]{fit_cie_model()}}.}
}
}
\description{
Fit and validate a CIE general sky model to radiance sampled on canopy
gaps and return the predicted raster.
}
\details{
Runs a the following pipeline:
\enumerate{
\item sky point extraction is performed with \code{\link[=extract_sky_points]{extract_sky_points()}}, using
information from a binary mask (\code{bin}) and post-filtering with
\code{\link[=rem_nearby_points]{rem_nearby_points()}} and \code{\link[=rem_outliers]{rem_outliers()}}.
\item relative radiance is computed with \code{\link[=extract_rr]{extract_rr()}} and fitted to CIE
sky models using \code{\link[=fit_cie_model]{fit_cie_model()}}, selecting the best among different
initial conditions and optimization methods.
\item model validation is performed via \code{\link[=validate_cie_model]{validate_cie_model()}}.
\item raster prediction with \code{\link[=cie_image]{cie_image()}}.
}
}
\note{
This function is part of a paper under preparation.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)

model <- ootb_cie_model(r, z, a, m)

bin <- ootb_bin(caim, z, a, m, TRUE)

set.seed(7)
gs <- list(
  #high res
  sky_grid_segmentation(z, a, 2.25, first_ring_different = TRUE),
  sky_grid_segmentation(z, a, 2.8125, first_ring_different = TRUE),
  #medium res
  sky_grid_segmentation(z, a, 9, first_ring_different = TRUE),
  sky_grid_segmentation(z, a, 10, first_ring_different = TRUE),
  #low res
  sky_grid_segmentation(z, a, 15, first_ring_different = FALSE),
  sky_grid_segmentation(z, a, 18, first_ring_different = FALSE)
)

sky_cie <- ootb_sky_cie(r, z, a, m, bin, gs,
                        method = c("Nelder-Mead", "BFGS", "CG", "SANN"),
                        min_spherical_dist = seq(0, 12, 3),
                        custom_sky_coef = model$coef,
                        parallel = TRUE)

sky_cie$rr_raster
plot(sky_cie$rr_raster)
sky_cie$model_validation$rmse
plot(sky_cie$model_validation$pred, sky_cie$model_validation$obs)
abline(0,1)

ratio <- r/sky_cie$rr_raster/sky_cie$model$rr$zenith_dn
plot(ratio)
plot(select_sky_region(ratio, 0.95, 1.05))
plot(select_sky_region(ratio, 1.15, max(ratio[], na.rm = TRUE)))

plot(bin)
points(sky_cie$sky_points$col,
       nrow(caim) - sky_cie$sky_points$row, col = 2, pch = 10)

}
}
