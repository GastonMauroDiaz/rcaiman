% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_cie_sky_model.R
\name{fit_cie_sky_model}
\alias{fit_cie_sky_model}
\title{Fit CIE sky model}
\usage{
fit_cie_sky_model(
  r,
  z,
  a,
  sky_points,
  zenith_dn,
  sun_coord,
  std_sky_no = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = FALSE,
  method = "BFGS"
)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically,
the blue channel extracted from an hemispherical photograph. Please see
\code{\link{read_caim}} and \code{\link{normalize}}.}

\item{z}{\linkS4class{SpatRaster}. The result of a call to
\code{\link{zenith_image}}.}

\item{a}{\linkS4class{SpatRaster}. The result of a call to
\code{\link{azimuth_image}}.}

\item{sky_points}{The data.frame returned by \code{\link{extract_zenith_dn}},
or a data.frame with the same structure and names.}

\item{zenith_dn}{Numeric vector of length 1. Zenith digital number, see
\code{\link{extract_zenith_dn}} for how to obtain it.}

\item{sun_coord}{An object of class list. The result of a call to
\code{\link{extract_sun_coord}}.}

\item{std_sky_no}{Numeric vector. Standard sky number from Table 1 from
\insertCite{Li2016;textual}{rcaiman}.}

\item{general_sky_type}{Character vector of length one. "Overcast", "Clear",
or "Partly cloudy". See Table 1 from \insertCite{Li2016;textual}{rcaiman}.}

\item{twilight}{Logical vector of length one. If it is \code{TRUE} and the
initial standard parameters belong to the "Clear" general sky type, sun
zenith angles from 90 to 96 degrees will be tested (civic twilight). This
is necessary since \code{\link{extract_sun_coord}} would mistakenly
recognize the gravity center of what can be seen of the solar corona as the
solar disk.}

\item{rmse}{Logical vector of length one. If it is \code{TRUE}, the criteria
for selecting the best sky model is to choose the one with lest root mean
square error calculated from the sample (sky marks). Otherwise, the
criteria is to evaluate the whole hemisphere by calculating the product
between the square ratio of \code{r} to the sky model and the fraction of
pixels from ratio above one or below zero, and selecting the sky
model that produce the least value.}

\item{method}{Optimization method to use. See \code{\link{optim}}.}
}
\description{
Fit CIE sky model using data from real hemispherical photographs.
}
\details{
This function use maximum likelihood to estimate the coefficients of the CIE
sky model that fit best to data sampled from a real image. The result include
the output produced by \code{\link[bbmle]{mle2}}, the 5 model coefficients,
observed and predicted values, the sun coordinates (zenith and azimuth angle
in degrees), the relative luminance calculated for every pixel using the
estimated coefficients and corresponding sun coordinate, the digital number
at the zenith, and the description of the standard sky from which the initial
coefficients were drawn. See \insertCite{Li2016;textual}{rcaiman} to known
more about these coefficients.

This function assume an hemispherical image as input. It is based on
\insertCite{Lang2010;textual}{rcaiman}. In theory, the better result would be
obtained with data showing a linear relation between digital numbers and the
amount of light reaching the sensor. However, the CIE sky model is indeed the
adjoin of two mathematical models, one controlling the gradation between the
zenith and the horizon (two parameters), and the other controlling the
gradation originated at the solar disk (three parameters). This make the CIE
model capable of cope with any non-linearity.

Ultimately, if the goal is to calculate the ratio of canopy DN to sky DN, if
the latter is accurately constructed, any non-linearity will be canceled.
Please, see code{link{interpolate_dns}} for further considerations.
}
\examples{
\dontrun{
caim <- read_caim() \%>\% normalize()
z <- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a <- azimuth_image(z)
sky_blue_sample <- crop(caim, ext(610,643,760,806))
sky_blue <- apply(sky_blue_sample[], 2, median) \%>\%
  as.numeric() \%>\%
  matrix(., ncol = 3) \%>\%
  sRGB()
ecaim <- enhance_caim(caim, !is.na(z), sky_blue, gamma = 2.2)
bin <- apply_thr(ecaim, 0.75)
g <- sky_grid_segmentation(z, a, 10)
blue <- gbc(caim$Blue*255)
sun_coord <- extract_sun_coord(blue, z, a, bin, g)
zenith_dn <- extract_zenith_dn(blue, z, a, sky_points)
model <- fit_cie_sky_model(blue, z, a, zenith_dn$sky_points,
                           zenith_dn$zenith_dn, sun_coord,
                           rmse = TRUE,
                           general_sky_type = "Partly cloudy")
sky_cie <- model$relative_luminance * model$zenith_dn
sky_cie[sky_cie > 1] <- 1
plot(sky_cie)
plot(blue/sky_cie)
}
}
\references{
\insertRef{Li2016}{rcaiman}
}
\seealso{
Other cie sky model functions: 
\code{\link{cie_sky_model_raster}()}
}
\concept{cie sky model functions}
