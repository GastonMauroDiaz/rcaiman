% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_cie_sky_model.R
\name{fit_cie_sky_model}
\alias{fit_cie_sky_model}
\title{Fit CIE sky model}
\usage{
fit_cie_sky_model(
  rl,
  sun_coord,
  custom_sky_coef = NULL,
  std_sky_no = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  method = "BFGS"
)
}
\arguments{
\item{rl}{An object of class \emph{list}. The result of a call to \code{\link[=extract_rl]{extract_rl()}}
or an object with same structure and names.}

\item{sun_coord}{An object of class \emph{list}. The result of a call to
\code{\link[=extract_sun_coord]{extract_sun_coord()}} or an object with same structure and names. See also
\code{\link[=row_col_from_zenith_azimuth]{row_col_from_zenith_azimuth()}} in case you want to provide values based on
date and time of acquisition and the \code{suncalc} package.}

\item{custom_sky_coef}{Numeric vector of length five or a numeric matrix with
five columns. Custom starting coefficients of the sky model. By default,
they are drawn from standard skies.}

\item{std_sky_no}{Numeric vector. Standard sky number from
\insertCite{Li2016;textual}{rcaiman}'s Table 1.}

\item{general_sky_type}{Character vector of length one. It could be any of
these: "Overcast", "Clear", or "Partly cloudy". See Table 1 from
\insertCite{Li2016;textual}{rcaiman} for additional details.}

\item{twilight}{Logical vector of length one. If it is \code{TRUE} and the initial
standard parameters belong to the "Clear" general sky type, sun zenith
angles from 90 to 96 degrees will be tested (civic twilight). This is
necessary since \code{\link[=extract_sun_coord]{extract_sun_coord()}} can mistakenly recognize the center
of what can be seen of the solar corona as the solar disk.}

\item{method}{Optimization method to use. See \code{\link{optim}}.}
}
\value{
An object of the class \emph{list}. The result includes the following: (1)
the output produced by \code{\link[bbmle:mle2]{bbmle::mle2()}}, (2) the 5 coefficients of the CIE
model, (3) observed values, (4) predicted values, (5) the digital number at
the zenith, (6) the sun coordinates (zenith and azimuth angle in degrees),
(7) the optimization method (see \code{\link[bbmle:mle2]{bbmle::mle2()}}), and the initial values
for optimizer (see \code{\link[bbmle:mle2]{bbmle::mle2()}}). To lear more about these initial
values, see \insertCite{Li2016;textual}{rcaiman}. If \code{\link[bbmle:mle2]{bbmle::mle2()}} does
not converge, (1) will be \code{NA} and (2) will contain the coefficients of a
standard sky (the one with less RMSE when more than one is tried).
}
\description{
Use maximum likelihood to estimate the coefficients of the CIE sky model that
best fit to data sampled from a canopy photograph.
}
\details{
This function is based on \insertCite{Lang2010;textual}{rcaiman}. In theory,
the best result would be obtained with data showing a linear relation between
digital numbers and the amount of light reaching the sensor. See
\code{\link[=extract_radiometry]{extract_radiometry()}} and \code{\link[=read_caim_raw]{read_caim_raw()}} for further details. As a
compromise solution, \code{\link[=gbc]{gbc()}} can be used.

The following code exemplifies how this package can be used to compare the
manually-guided fitting provided by HSP \insertCite{Lang2013}{rcaiman}
against the automatic fitting provided by this package. The code assumes that
the user is working within an RStudio project located in the HSP project
folder.

\if{html}{\out{<div class="sourceCode">}}\preformatted{r <- read_caim("manipulate/IMG_1013.pgm") \%>\% normalize()
z <- zenith_image(ncol(r), lens())
a <- azimuth_image(z)
manual_input <- read_manual_input(".", "IMG_1013" )
sun_coord <- manual_input$sun_coord$row_col
sun_coord <- zenith_azimuth_from_row_col(z, sun_coord, lens())
sky_points <- manual_input$sky_points
rl <- extract_rl(r, z, a, sky_points)
model <- fit_cie_sky_model(rl, sun_coord)
cie_sky <- model$relative_luminance * model$zenith_dn
plot(r/cie_sky)

r <- read_caim("manipulate/IMG_1013.pgm")
sky_coef <- read_opt_sky_coef(".", "IMG_1013")
cie_sky_m <- cie_sky_model_raster(z, a, sun_coord$zenith_azimuth, sky_coef)
cie_sky_m <- cie_sky_manual * manual_input$zenith_dn
plot(r/cie_sky_m)
}\if{html}{\out{</div>}}
}
\note{
The \href{https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool}{point selection tool of ‘ImageJ’ software}
can be used to manually digitize points and create a CSV file from which to
read coordinates (see Examples). After digitizing the points on the image,
use the dropdown menu Analyze>Measure to open the Results window. To obtain
the CSV file, use File>Save As...

The \href{https://qgis.org/}{QGIS software} can also be used to manually digitize
points. In order to do that, drag and drop the image in an empty project,
create an new vector layer, digitize points manually, save the editions, and
close the project. To create the new vector layer go to the dropdown menu
Layer>Create Layer>New Geopackage Layer...

Choose "point" in the Geometry type dropdown list and make sure the CRS is
EPSG:7589. To be able to input the points, remember to click first on the
Toogle Editing icon, and then on the Add Points Feature icon.

If you use this function in your research, please cite
\insertCite{Lang2010;textual}{rcaiman} in addition to this package
(\verb{citation("rcaiman"})).
}
\examples{
\dontrun{
caim <- read_caim() \%>\% normalize()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)

# Manual method following Lang et al. (2010)
# ImageJ can be used to digitize points
path <- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points <- read.csv(path)
sky_points <- sky_points[c("Y", "X")]
colnames(sky_points) <- c("row", "col")
head(sky_points)
plot(caim$Blue)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

# Idem for QGIS
path <- system.file("external/sky_points.gpkg",
                    package = "rcaiman")
sky_points <- terra::vect(path)
sky_points <- terra::extract(caim, sky_points, cells = TRUE)
sky_points <- terra::rowColFromCell(caim, sky_points$cell) \%>\% as.data.frame()
colnames(sky_points) <- c("row", "col")
head(sky_points)
plot(caim$Blue)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

xy <- c(210, 451) #taken with click() after x11(), then hardcoded here
sun_coord <- zenith_azimuth_from_row_col(z, a, c(nrow(z) - xy[2],xy[1]))
points(sun_coord$row_col[2], nrow(caim) - sun_coord$row_col[1],
       col = 3, pch = 1)

rl <- extract_rl(caim$Blue, z, a, sky_points)

set.seed(7)
model <- fit_cie_sky_model(rl, sun_coord,
                           general_sky_type = "Clear",
                           twilight = FALSE,
                           method = "CG")
summary(model$mle2_output)
plot(model$obs, model$pred)
abline(0,1)
lm(model$pred~model$obs) \%>\% summary()

sky_cie <- cie_sky_model_raster(z, a,
                                model$sun_coord$zenith_azimuth,
                                model$coef) * model$zenith_dn
plot(sky_cie)
plot(caim$Blue/sky_cie)
}
}
\references{
\insertAllCited{}
}
\seealso{
Other Sky Reconstruction Functions: 
\code{\link{cie_sky_model_raster}()},
\code{\link{fit_coneshaped_model}()},
\code{\link{fit_trend_surface}()},
\code{\link{interpolate_and_merge}()},
\code{\link{interpolate_sky_points}()},
\code{\link{ootb_sky_reconstruction}()}
}
\concept{Sky Reconstruction Functions}
