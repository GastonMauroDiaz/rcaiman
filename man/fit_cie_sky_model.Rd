% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_cie_sky_model.R
\name{fit_cie_sky_model}
\alias{fit_cie_sky_model}
\title{Fit CIE sky model}
\usage{
fit_cie_sky_model(
  r,
  z,
  a,
  sky_points,
  zenith_dn,
  sun_coord,
  std_sky_no = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = FALSE,
  method = "BFGS"
)
}
\arguments{
\item{r}{\linkS4class{SpatRaster}. A normalized greyscale image. Typically,
the blue channel extracted from an hemispherical photograph. Please see
\code{\link{read_caim}} and \code{\link{normalize}}.}

\item{z}{\linkS4class{SpatRaster} built with \code{\link{zenith_image}}.}

\item{a}{\linkS4class{SpatRaster} built with \code{\link{azimuth_image}}.}

\item{sky_points}{The \emph{data.frame} returned by \code{\link{extract_rl}},
or a \emph{data.frame} with the same structure and names.}

\item{zenith_dn}{Numeric vector of length 1. Zenith digital number, see
\code{\link{extract_rl}} for how to obtain it.}

\item{sun_coord}{An object of class \emph{list}. The result of a call to
\code{\link{extract_sun_coord}}.}

\item{std_sky_no}{Numeric vector. Standard sky number from Table 1 from
\insertCite{Li2016;textual}{rcaiman}.}

\item{general_sky_type}{Character vector of length one. It could be any of
these: "Overcast", "Clear", or "Partly cloudy". See Table 1 from
\insertCite{Li2016;textual}{rcaiman} for additional details.}

\item{twilight}{Logical vector of length one. If it is \code{TRUE} and the
initial standard parameters belong to the "Clear" general sky type, sun
zenith angles from 90 to 96 degrees will be tested (civic twilight). This
is necessary since \code{\link{extract_sun_coord}} would mistakenly
recognize the center of what can be seen of the solar corona as the solar
disk.}

\item{rmse}{Logical vector of length one. If it is \code{TRUE}, the criteria
for selecting the best sky model is to choose the one with lest root mean
square error calculated from the sample (sky marks). Otherwise, the
criteria is to evaluate the whole hemisphere by calculating the product
between the square ratio of \code{r} to the sky model and the fraction of
pixels from this new layer that are above one or below zero, and selecting
the sky model that produce the least value.}

\item{method}{Optimization method to use. See \code{\link{optim}}.}
}
\value{
The result include the output produced by \code{\link[bbmle]{mle2}},
  the 5 model coefficients, observed and predicted values, the sun
  coordinates (zenith and azimuth angle in degrees), the relative luminance
  calculated for every pixel using the estimated coefficients and
  corresponding sun coordinate, the digital number at the zenith, and the
  description of the standard sky from which the initial coefficients were
  drawn. See \insertCite{Li2016;textual}{rcaiman} to known more about these
  coefficients.
}
\description{
Use maximum likelihood to estimate the coefficients of the CIE sky model that
fit best to data sampled from a real scene.
}
\details{
This function assumes an hemispherical image as input. It is based on
\insertCite{Lang2010;textual}{rcaiman}. In theory, the better result would be
obtained with data showing a linear relation between digital numbers and the
amount of light reaching the sensor. However, because the CIE sky model is
indeed the adjoin of two mathematical model, it is capable of cope with any
non-linearity since it is not a physical model with strict assumptions.

Ultimately, if the goal is to calculate the ratio of canopy to sky digital
numbers, if the latter is accurately constructed, any non-linearity will be
canceled. Please, see \code{\link{interpolate_sky_points}} for further
considerations.
}
\examples{
\dontrun{
caim <- read_caim() \%>\% normalize()
z <- zenith_image(ncol(caim), lens("Nikon_FCE9"))
a <- azimuth_image(z)
sky_blue_sample <- crop(caim, ext(610,643,760,806))
sky_blue <- apply(sky_blue_sample[], 2, median) \%>\%
  as.numeric() \%>\%
  matrix(., ncol = 3) \%>\%
  sRGB()
ecaim <- enhance_caim(caim, !is.na(z), sky_blue, gamma = 2.2)
bin <- apply_thr(ecaim, 0.75)
g <- sky_grid_segmentation(z, a, 10)
r <- gbc(caim$Blue*255)
sun_coord <- extract_sun_coord(r, z, a, bin, g)
sky_points <- extract_sky_points(r, bin, g)
rl <- extract_rl(r, z, a, sky_points)
model <- fit_cie_sky_model(r, z, a, rl$sky_points,
                           rl$zenith_dn, sun_coord,
                           rmse = TRUE,
                           general_sky_type = "Partly cloudy")
sky_cie <- model$relative_luminance * model$zenith_dn
sky_cie <- normalize(sky_cie, 0, 1, TRUE)
plot(sky_cie)
plot(r/sky_cie)
}
}
\references{
\insertAllCited{}
}
\seealso{
Other Sky Reconstruction Functions: 
\code{\link{cie_sky_model_raster}()},
\code{\link{fit_coneshaped_model}()},
\code{\link{fit_trend_surface}()},
\code{\link{fix_reconstructed_sky}()},
\code{\link{interpolate_sky_points}()}
}
\concept{Sky Reconstruction Functions}
