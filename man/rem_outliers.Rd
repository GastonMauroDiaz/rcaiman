% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rem_outliers.R
\name{rem_outliers}
\alias{rem_outliers}
\title{Remove statistical outliers in sky points}
\usage{
rem_outliers(
  sky_points,
  r,
  z,
  a,
  k = 20,
  angular_radius = 20,
  laxity = 2,
  cutoff_side = "both",
  use_window = TRUE,
  detrend = FALSE,
  parallel = FALSE,
  cores = NULL,
  logical = TRUE,
  leave_free = 1
)
}
\arguments{
\item{sky_points}{\code{data.frame} with columns \code{row} and \code{col} (raster
coordinates).}

\item{r}{\link[terra:SpatRaster-class]{terra::SpatRaster}. Image from which \code{sky_points} were
sampled (or any raster with identical dimensions).}

\item{z}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=zenith_image]{zenith_image()}}.}

\item{a}{\link[terra:SpatRaster-class]{terra::SpatRaster} generated with \code{\link[=azimuth_image]{azimuth_image()}}.}

\item{k}{numeric vector of length one. Number of neighbors.}

\item{angular_radius}{numeric vector of length one. The maximum radius for
searching k-nearest neighbors (KNN) in degrees.}

\item{laxity}{numeric vector of length one. Positive multiplier applied to
MAD to set classification thresholds. Default is \code{2}.}

\item{cutoff_side}{character vector of length one. One of \code{"both"},
\code{"left"}, or \code{"right"}. Default is \code{"both"}.}

\item{use_window}{logical vector of length one. If \code{TRUE} (default), the
digital number at each sky point is the average of the values extracted
from input \code{r} with a window of \eqn{3 \times 3} pixels centered on the
pixel that includes the point. If \code{FALSE}, only the value of the central
pixel is retrieved.}

\item{detrend}{logical vector of length one. When \code{TRUE}, a detrending is
attempted with \code{\link[=fit_coneshaped_model]{fit_coneshaped_model()}} with \code{method = zenith_n_azimuth}. If
this attempt fails, the function reverts to \code{detrend = FALSE} and searches
for outliers in the untransformed values. Detrending fails systematically
when \code{k < 20}.}

\item{parallel}{logical vector of length one. If \code{TRUE}, operations are
executed in parallel.}

\item{cores}{numeric vector of length one. Number of CPU cores to use when
\code{parallel = TRUE}. If \code{NULL}, the function uses all available
cores detected internally. Values greater than the number of available
cores are silently reduced to the maximum allowed. If the resulting number
of cores is less than 2, \code{parallel} is silently set to \code{FALSE}.}

\item{logical}{logical vector of length one. Internally it is passed unchanged
to the argument \code{logical} in \code{\link[parallel:detectCores]{parallel::detectCores()}}. Ignored when
\code{parallel = FALSE}.}

\item{leave_free}{numeric vector of length one. Number of CPU cores to leave
free when \code{parallel = TRUE}. Ignored when \code{cores} is not \code{NULL}. Must be
greater than or equal to 0. If \code{total_cores - leave_free} is less than 2,
\code{parallel} is silently set to \code{FALSE}.}
}
\value{
The retained points represented as a \link{data.frame} with columns \code{row}
and \code{col}, same as \code{sky_points}.
}
\description{
Remove sky points considered outliers relative to their local
neighbors in a user-specified variable.
}
\details{
Based on the Statistical Outlier Removal (SOR) filter from the
\href{https://pointclouds.org/}{PCL library}. Distances are computed on a spherical
surface. The number of neighbors is controlled by \code{k}, and \code{angular_radius}
sets the maximum search radius (deg). If fewer than \code{k} neighbors are found
within that radius, the point is retained due to insufficient evidence for
removal. The decision criterion is from \code{\link[=is_outlier]{is_outlier()}}.
}
\note{
This function assumes that \code{sky_points} and the
\link[terra:SpatRaster-class]{terra::SpatRaster} objects refer to the same image geometry. No checks
are performed.
}
\examples{
\dontrun{
caim <- read_caim()
r <- caim$Blue
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
bin <- binarize_by_region(r, ring_segmentation(z, 30),
                          method = "thr_isodata")
bin <- bin & select_sky_region(z, 0, 80)
seg <- equalarea_segmentation(z, a, 1000)
sky_points <- sample_sky_points(r, bin, seg,
                                dist_to_black = 3)
plot(r)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

sky_points2 <- rem_outliers(sky_points, r, z, a,
                            k = 20,
                            angular_radius = 30,
                            laxity = 2,
                            cutoff_side = "left",
                            detrend = TRUE)
points(sky_points2$col, nrow(caim) - sky_points2$row, col = 3, pch = 0)
}
}
