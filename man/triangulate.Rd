% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/triangulate.R
\name{triangulate}
\alias{triangulate}
\title{Interpolate with Delaunay triangulation}
\usage{
triangulate(sky_points, r, col_id = "dn")
}
\arguments{
\item{sky_points}{\code{data.frame} with columns \code{row}, \code{col}, and one additional
numeric column with values to interpolate. Typically returned by
\code{\link[=extract_rr]{extract_rr()}} or \code{\link[=extract_dn]{extract_dn()}}.}

\item{r}{numeric \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer. Image from which
\code{sky_points} were derived, or another raster with the same number of rows
and columns. Used only as geometric template; cell values are ignored.}

\item{col_id}{numeric or character vector of length one. The name or position
of the column in \code{sky_points} containing the values to interpolate.}
}
\value{
Numeric \link[terra:SpatRaster-class]{terra::SpatRaster} with one layer and the same geometry
as \code{r}.
}
\description{
Interpolate pixel values from irregularly spaced points using planar
surfaces defined by Delaunay triangles.
}
\details{
Each triangle defines a plane estimated from its three vertices, and
interpolation is performed by evaluating the plane equation at each
pixel position. This approach produces a continuous surface with
sharp transitions at triangle borders.
}
\note{
The function internally uses \code{\link[terra:voronoi]{terra::delaunay()}} to construct the
triangulated mesh.
}
\examples{
\dontrun{
caim <- read_caim()
z <- zenith_image(ncol(caim), lens())
a <- azimuth_image(z)
m <- !is.na(z)
r <- caim$Blue

bin <- binarize_by_region(r, ring_segmentation(z, 15), "thr_isodata") &
  select_sky_region(z, 0, 88)

g <- sky_grid_segmentation(z, a, 10)
sky_points <- extract_sky_points(r, bin, g, dist_to_black = 3)
plot(bin)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)
sky_points <- extract_dn(r, sky_points)

sky <- triangulate(sky_points, r, col_id = 3)
plot(sky)
}
}
